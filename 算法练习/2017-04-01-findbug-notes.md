---
layout: post
title:  FindBugs常见错误提示及解决
date:   2017-04-01
categories: JAVA & kotlin
tag: 杂项
---
 


#### ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD ####
>This instance method writes to a static field. This is tricky to get correct if multiple instances are being manipulated, and generally bad practice.
>静态字段被实例方法修改。如果多个实例被操纵，这样获取正确的结果是滑头的，并且通常不是好的实践。


原因：静态私有的成员变量不能在public类里面直接赋值，最好是通过get/set方法进行操作。直接通过类名.常量名获取的方式违背了封装的原则，findbugs不提倡使用。
<br/>

解决：通过get/set方法提供操作。

#### DM_BOXED_PRIMITIVE_FOR_PARSING ####
>A boxed primitive is created from a String, just to extract the unboxed primitive value. It is more efficient to just call the static parseXXX method.
>一个装箱的原语是由字符串创建，只是为了拆箱获取原始值。使用parseXXX方法更加有效。

原因：

- static int parseInt(String s):       将字符串参数作为有符号的十进制整数进行分析，返回一个int值。
- static Integer valueOf(int i) :      返回一个表示指定的 int 值的 Integer 实例。
- static Integer valueOf(String s) :      返回保持指定的 String 的值的 Integer 对象（实例）。

解决：parseXXX方法代替valueOf

#### SS_SHOULD_BE_STATIC ####
>This class contains an instance final field that is initialized to a compile-time static value. Consider making the field static.
>类包含一个初始化于编译期静态值的不可变实例字段。考虑使用static修饰该字段。

解决方法：final的字段可以定义为static类型

#### DLS_DEAD_LOCAL_STORE ####
>This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. Often, this indicates an error, because the value computed is never used.<br/>
Note that Sun's javac compiler often generates dead stores for final local variables. Because FindBugs is a bytecode-based tool, there is no easy way to eliminate these false positives.
该指令把一个值分配给本地变量，但是值并没有被读取或使用。通常这表示错误，因为这个值从来没有被用到过。<br/>
请注意，Sun公司的javac编译器通常为本地final变量生成死存储。因为FindBugs是基于字节码的工具，因此没有简单的方法可以消除这些误报。

解决方法：注释掉。


#### SF_SWITCH_NO_DEFAULT ####
>This method contains a switch statement where default case is missing. Usually you need to provide a default case.
Because the analysis only looks at the generated bytecode, this warning can be incorrect triggered if the default case is at the end of the switch statement and the switch statement doesn't contain break statements for other cases.
此方法包含一个缺省情况下的switch语句。通常你需要提供一个默认的情况。
<br/>
因为分析仅查看生成的字节码，这个警告可能会被错误除法。如果默认的情况下是switch语句结尾并且switch语句不包含其他情况的break语句。

解决方法：加上default。


#### RV_RETURN_VALUE_IGNORED_BAD_PRACTICE ####

>This method returns a value that is not checked.The return value should be checked since it can indicate an unusual or unexpected function. For example, the `File.delete()` method returns false if the file could not be successfully deleted(rather than throwing an Exception).if you don't check the result, you won't notice if the method invocation signals unexpected behavior by returning an a typical return value. 
>此方法返回了一个boolean，但没有去检查。这个值应该被检查，因为他可以指示异常或意外的功能。例如，`File.dlete()`方法返回false，如果这个文件可以被成功删除，而不是抛出异常。如果你没有检查，你就不会注意到这个方法通过返回一个典型错误，调用出现不可期的行为。


#### DC_DOUBLECHECK ####

>This method may contain an instance of double-checked locking. This idion is not correct according to the semantics of the Java memory model.

see more:[双重检查锁定与延迟初始化](http://www.infoq.com/cn/articles/double-checked-locking-with-delay-initialization#)

#### NM_METHOD_NAMING_CONVENTION ####

>Methods should be verbs, in mixed case with the first letter lowercase, with the first letter of each internal word capitalized.
>方法名开头要小写。