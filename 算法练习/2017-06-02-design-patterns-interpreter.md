---
title: 解释器模式
date: 2017-06-02 09:39:35
tags: 设计模式
categories: Design Pattern
---

#### 定义 ####

解释器模式(Interpreter Pattern)：定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。
解释器模式是一种行为型模式。
#### 类图 ####
- Context(环境类)：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。
- AbstractExpression(抽象表达式)：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。
- TerminalExpression(终结符表达式)：终结符表达式是抽象表达式的实现，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式，它们的实例可以通过非终结符表达式组成较为复杂的句子。
- NonterminalExpression(非终结符表达式)：非终结符表达式也实现了抽象表达式，它实现的是文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。

![类图](/images/interpreter_class_diagram.png)

#### 代码 ####

[GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/InterpreterPattern)

#### 分析 ####

- 为自定义语言的设计和实现提供了一种解决方案
- 使用频率不高，在正则表达式、xml文档解析等领域广泛应用
- 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言，因此对于复杂的文法，难以维护
- 使用了大量的循环和递归，导致执行效率很低
- 尽量不要在重要模块使用解释器模式，否则维护是一个大问题，在项目中可以使用shell、JRuby、Groovy等脚本语言来代替解释器模式，弥补Java编译型语言的不足
- 一般在大中型的框架型项目能够找到它的身影，比如数据分析工具、报表设计工具、科学计算工具
- 如果的确准备使用解释器模式，请参考Expression4J、MESP、Jep等开源的解析工具包的实现