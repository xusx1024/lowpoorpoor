---
layout: post
title:  策略模式
date:   2017-05-25
categories: Design Pattern
tags: 设计模式
---
 

#### what ####
 
策略模式是对象行为型模式<br>

策略模式(Strategy Pattern):定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy Pattern).

#### 模式结构 ####

-  Context:环境类
-  Strategy：抽象策略类
-  ConcreteStrategy：具体策略类
	
 
![类图](/images/strategy_pattern_class_diagram.png)

#### 时序图 ####

![时序图](/images/strategy_pattern_sequence_diagram.png)

#### 代码 ####

 [GitHub](https://github.com/xusx1024/DesignPatternDemoCode/tree/master/StrategyPattern)

#### 分析 ####

- 在软件系统中，有许多算法可以实现某一功能，如查找，排序等，一种常用的方法是硬编码在一个类中，如果需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法，当然也可以将这些查找算法封装在一个统一的方法中，通过if...else...等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将比较复杂，维护困难
- 为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为策略，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体的策略类。


#### 优劣 ####

- 对开闭原则完美支持，用户自由切换算法，易于扩展
- 可以避免使用多重条件转移语句

- 必须对调用者暴露所有的策略类，客户端必须知道有什么策略，及其区别，这有悖于迪米特法则
- 需要维护许多策略类